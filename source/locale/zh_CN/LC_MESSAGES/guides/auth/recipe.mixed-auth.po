# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2019, BandCap
# This file is distributed under the same license as the feathers docs
# package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2019.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: feathers docs \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-06-22 19:53+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.6.0\n"

#: ../../source/guides/auth/recipe.mixed-auth.rst:2
msgid "Create Endpoints with Mixed Auth"
msgstr "使用混合身份验证创建端点"

#: ../../source/guides/auth/recipe.mixed-auth.rst:4
msgid ""
"The Auk release of FeathersJS includes a powerful new "
":doc:`../../api/authentication/server` built on top of `PassportJS "
"<http://www.passportjs.org/>`_. It can be customized to handle almost any"
" app’s authentication requirements. In this guide, we’ll look at how to "
"handle a fairly common auth scenario: Sometimes an endpoint needs to "
"serve different information depending on whether the user is "
"authenticated. An unauthenticated user might only see public records. An "
"authenticated user might be able to see additional records."
msgstr "FeatusJS的Auk版本包括一个强大的新的 :doc:`../../api/authentication/server` 建立在 `PassportJS <http://www.passportjs.org/>`_ 之上.它可以自定义以处理几乎任何应用程序的身份验证要求.在本指南中,我们将介绍如何处理相当常见的身份验证方案:有时端点需要根据用户是否经过身份验证来提供不同的信息.未经身份验证的用户可能只会看到公共记录.经过身份验证的用户可能能够看到其他记录."

#: ../../source/guides/auth/recipe.mixed-auth.rst:13
msgid "Setup the Authentication Endpoint"
msgstr "设置身份验证端点"

#: ../../source/guides/auth/recipe.mixed-auth.rst:15
msgid ""
"To get started, we need a working authentication setup. Below is a "
"default configuration and ``authentication.js``. They contain the same "
"code generated by the `feathers-cli "
"<https://github.com/feathersjs/cli>`_. You can create the below setup "
"using the following terminal commands:"
msgstr ""
"首先,我们需要一个有效的身份验证设置.下面是默认配置和 ``authentication.js``.它们包含由 `feathers-cli "
"<https://github.com/feathersjs/cli>`_ 生成的相同代码.您可以使用以下终端命令创建以下设置:"

#: ../../source/guides/auth/recipe.mixed-auth.rst:21
msgid "``npm install -g @feathersjs/cli``\\"
msgstr "``npm install -g @feathersjs/cli``\\"

#: ../../source/guides/auth/recipe.mixed-auth.rst:22
msgid ""
"``mkdir feathers-demo-local; cd feathers-demo-local``\\  or a folder name"
" you prefer."
msgstr "``mkdir feathers-demo-local; cd feathers-demo-local``\\  或您喜欢的文件夹名称."

#: ../../source/guides/auth/recipe.mixed-auth.rst:24
msgid "``feathers generate app``\\  use the default prompts."
msgstr "``feathers generate app``\\  使用默认提示."

#: ../../source/guides/auth/recipe.mixed-auth.rst:25
msgid "``feathers generate authentication``"
msgstr "``feathers generate authentication``"

#: ../../source/guides/auth/recipe.mixed-auth.rst:27
msgid "Select ``Username + Password (Local)`` when prompted for a provider."
msgstr "提示输入提供商时,选择“用户名+密码(本地)”."

#: ../../source/guides/auth/recipe.mixed-auth.rst:29
msgid "Select the defaults for the remaining prompts."
msgstr "选择其余提示的默认值."

#: ../../source/guides/auth/recipe.mixed-auth.rst:31
msgid "**config/default.json:**"
msgstr "**config/default.json:**"

#: ../../source/guides/auth/recipe.mixed-auth.rst:71
msgid "**src/authentication.js:**"
msgstr "**src/authentication.js:**"

#: ../../source/guides/auth/recipe.mixed-auth.rst:102
msgid "Set up a “Mixed Auth” Endpoint"
msgstr "设置“混合验证”端点"

#: ../../source/guides/auth/recipe.mixed-auth.rst:104
msgid ""
"Now we need to setup an endpoint to handle both unauthenticated and "
"authenticated users. For this example, we’ll use the ``/users`` service "
"that was already created by the authentication generator. Let’s suppose "
"that our application requires that each ``user`` record will contain a "
"``public`` boolean property. Each record will look something like this:"
msgstr "现在我们需要设置一个端点来处理未经身份验证和经过身份验证的用户.对于此示例,我们将使用已由身份验证生成器创建的 ``/users`` 服务.假设我们的应用程序要求每个 ``user`` 记录都包含一个 ``public`` 布尔属性.每条记录看起来都像这样:"

#: ../../source/guides/auth/recipe.mixed-auth.rst:119
msgid ""
"If a ``user`` record contains ``public: true``, then **unauthenticated** "
"users should be able to access it. Let’s see how to use the ``iff`` and "
"``else`` conditional hooks from `feathers-hooks-common <https://feathers-"
"plus.github.io/v1/feathers-hooks-common/>`_ to make this happen. Be sure "
"to read the `iff hook API docs <https://feathers-plus.github.io/v1"
"/feathers-hooks-common/#iff>`_ and `else hook API docs <https://feathers-"
"plus.github.io/v1/feathers-hooks-common/#else>`_ if you haven’t, yet."
msgstr "如果 ``user`` 记录包含 ``public:true``,则 **未经身份验证的** 用户应该能够访问它. 让我们看看如何使用来自 `feathers-hooks-common <https://feathers-plus.github.io/v1/feathers-hooks-common/>`_ 的 ``iff`` 和 ``else`` 条件钩子.实现这一目标. 一定要阅读 `iff hook API docs <https://feathers-plus.github.io/v1/feathers-hooks-common/#iff>`_ 和 `else hook API docs <https://feathers-plus .github.io/v1/feathers-hooks-common/#else>`_ 如果你还没有."

#: ../../source/guides/auth/recipe.mixed-auth.rst:129
msgid ""
"We’re going to use the ``iff`` hook to authenticate users only if a token"
" is in the request. The :doc:`../../api/authentication/jwt`. which we "
"used in ``src/authentication.js``, includes a token extractor. If a "
"request includes a token, it will automatically be available inside the "
"``context`` object at ``context.params.token``."
msgstr ""
"只有在请求中有令牌时,我们才会使用 ``iff`` 钩子来验证用户身份. "
":doc:`../../api/authentication/jwt`.我们在 ``src/authentication.js`` 中使用的,包括一个令牌提取器.如果请求包含一个令牌,它将自动在 ``context.params.token`` 的 ``context`` 对象中可用."

#: ../../source/guides/auth/recipe.mixed-auth.rst:135
msgid ""
"**src/services/users/users.hooks.js**\\  (This example only shows the "
"``find`` method’s ``before`` hooks.)"
msgstr ""
"**src/services/users/users.hooks.js**\\ (这个例子只显示 ``find`` 方法的 ``before`` 钩子.)"

#: ../../source/guides/auth/recipe.mixed-auth.rst:158
msgid ""
"Let’s break down the above example. We setup the ``find`` method of the "
"``/users`` service with an ``iff`` conditional before hook:"
msgstr "让我们分解上面的例子.我们在钩子之前使用 ``iff`` 条件设置 ``/users`` 服务的 ``find`` 方法:"

#: ../../source/guides/auth/recipe.mixed-auth.rst:168
msgid ""
"For this application, the above snippet is equivalent to the snippet, "
"below."
msgstr "对于此应用程序,上面的代码段相当于下面的代码段."

#: ../../source/guides/auth/recipe.mixed-auth.rst:181
msgid ""
"The ``iff`` hook is actually more capable than the simple demonstration, "
"above. It can handle an async predicate expression. This would be "
"equivalent to being able to pass a ``promise`` inside the ``if`` "
"statement’s parentheses. It also allows us to chain an \\ ``.else()`` "
"statement, which will run if the predicate evaluates to false."
msgstr "``iff`` 钩实际上比上面的简单演示更有能力.它可以处理异步谓词表达式.这相当于能够在 ``if`` 语句的括号内传递 ``promise``.它还允许我们链接一个\\ ``.else()`` 语句,如果谓词的计算结果为false,它将运行."

#: ../../source/guides/auth/recipe.mixed-auth.rst:195
msgid ""
"The above statement simply adds ``public: true`` to the query parameters."
" This limits the query to only find ``user`` records that have the "
"``public`` property set to ``true``."
msgstr ""
"上面的语句只是将 ``public:true`` 添加到查询参数中.这限制了查询只能找到 ``public`` 属性设置为 ``true`` 的 ``user`` 记录."

#: ../../source/guides/auth/recipe.mixed-auth.rst:200
msgid "Wrapping Up"
msgstr "包起来"

#: ../../source/guides/auth/recipe.mixed-auth.rst:202
msgid ""
"With the above code, we’ve successfully setup a ``/users`` service that "
"responds differently to unauthenticated and authenticated users. We used "
"the ``context.params.token`` attribute to either authenticate a user or "
"to limit the search query to only public users. If you become familiar "
"with the `Common Hooks API <https://feathers-plus.github.io/v1/feathers-"
"hooks-common/>`_, you’ll be able to solve almost any authentication "
"puzzle."
msgstr ""
"通过上面的代码,我们成功地设置了一个 ``/users`` 服务,该服务对未经身份验证和验证的用户做出不同的响应.我们使用 ``context.params.token`` 属性来验证用户或将搜索查询限制为仅限公共用户.如果您熟悉 `Common"
" Hooks API <https://feathers-plus.github.io/v1/feathers-hooks-"
"common/>`_,您将能够解决几乎所有的身份验证难题."
